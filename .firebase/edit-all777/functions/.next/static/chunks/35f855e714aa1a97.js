(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,61721,56916,e=>{"use strict";var s,r;(r=s||(s={})).LOAD="LOAD",r.EXEC="EXEC",r.FFPROBE="FFPROBE",r.WRITE_FILE="WRITE_FILE",r.READ_FILE="READ_FILE",r.DELETE_FILE="DELETE_FILE",r.RENAME="RENAME",r.CREATE_DIR="CREATE_DIR",r.LIST_DIR="LIST_DIR",r.DELETE_DIR="DELETE_DIR",r.ERROR="ERROR",r.DOWNLOAD="DOWNLOAD",r.PROGRESS="PROGRESS",r.LOG="LOG",r.MOUNT="MOUNT",r.UNMOUNT="UNMOUNT",e.s(["CORE_URL",0,"https://unpkg.com/@ffmpeg/core@0.12.9/dist/umd/ffmpeg-core.js","FFMessageType",()=>s],61721);let a=Error("unknown message type"),t=Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),E=Error("called FFmpeg.terminate()"),R=Error("failed to import ffmpeg-core.js");e.s(["ERROR_IMPORT_FAILURE",0,R,"ERROR_NOT_LOADED",0,t,"ERROR_TERMINATED",0,E,"ERROR_UNKNOWN_MESSAGE_TYPE",0,a],56916)},4210,e=>{"use strict";let s;var r=e.i(61721),a=e.i(56916);let t=async({coreURL:e,wasmURL:t,workerURL:E})=>{let R=!s;try{e||(e=r.CORE_URL),importScripts(e)}catch{if(e&&e!==r.CORE_URL||(e=r.CORE_URL.replace("/umd/","/esm/")),self.createFFmpegCore=(await Promise.resolve().then(()=>{let e=Error("Cannot find module as expression is too dynamic");throw e.code="MODULE_NOT_FOUND",e})).default,!self.createFFmpegCore)throw a.ERROR_IMPORT_FAILURE}let F=e,o=t||e.replace(/.js$/g,".wasm"),T=E||e.replace(/.js$/g,".worker.js");return(s=await self.createFFmpegCore({mainScriptUrlOrBlob:`${F}#${btoa(JSON.stringify({wasmURL:o,workerURL:T}))}`})).setLogger(e=>self.postMessage({type:r.FFMessageType.LOG,data:e})),s.setProgress(e=>self.postMessage({type:r.FFMessageType.PROGRESS,data:e})),R};self.onmessage=async({data:{id:e,type:E,data:R}})=>{let F,o=[];try{if(E!==r.FFMessageType.LOAD&&!s)throw a.ERROR_NOT_LOADED;switch(E){case r.FFMessageType.LOAD:F=await t(R);break;case r.FFMessageType.EXEC:F=(({args:e,timeout:r=-1})=>{s.setTimeout(r),s.exec(...e);let a=s.ret;return s.reset(),a})(R);break;case r.FFMessageType.FFPROBE:F=(({args:e,timeout:r=-1})=>{s.setTimeout(r),s.ffprobe(...e);let a=s.ret;return s.reset(),a})(R);break;case r.FFMessageType.WRITE_FILE:F=(({path:e,data:r})=>(s.FS.writeFile(e,r),!0))(R);break;case r.FFMessageType.READ_FILE:F=(({path:e,encoding:r})=>s.FS.readFile(e,{encoding:r}))(R);break;case r.FFMessageType.DELETE_FILE:F=(({path:e})=>(s.FS.unlink(e),!0))(R);break;case r.FFMessageType.RENAME:F=(({oldPath:e,newPath:r})=>(s.FS.rename(e,r),!0))(R);break;case r.FFMessageType.CREATE_DIR:F=(({path:e})=>(s.FS.mkdir(e),!0))(R);break;case r.FFMessageType.LIST_DIR:F=(({path:e})=>{let r=s.FS.readdir(e),a=[];for(let t of r){let r=s.FS.stat(`${e}/${t}`),E=s.FS.isDir(r.mode);a.push({name:t,isDir:E})}return a})(R);break;case r.FFMessageType.DELETE_DIR:F=(({path:e})=>(s.FS.rmdir(e),!0))(R);break;case r.FFMessageType.MOUNT:F=(({fsType:e,options:r,mountPoint:a})=>{let t=s.FS.filesystems[e];return!!t&&(s.FS.mount(t,r,a),!0)})(R);break;case r.FFMessageType.UNMOUNT:F=(({mountPoint:e})=>(s.FS.unmount(e),!0))(R);break;default:throw a.ERROR_UNKNOWN_MESSAGE_TYPE}}catch(s){self.postMessage({id:e,type:r.FFMessageType.ERROR,data:s.toString()});return}F instanceof Uint8Array&&o.push(F.buffer),self.postMessage({id:e,type:E,data:F},o)},e.s([])}]);